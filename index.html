<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<title>This is War - Wave Survival</title>
<style>
body { margin:0; background:#111; overflow:hidden; font-family:sans-serif; touch-action:none; -webkit-user-select:none; -ms-user-select:none; user-select:none; }
canvas { display:block; background:#1e1e1e; }
#ui { position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; }
.btn { position:absolute; bottom:30px; width:80px; height:80px; border-radius:12px; background:#444; color:#fff; font-weight:bold;
  display:flex; align-items:center; justify-content:center; pointer-events:auto; user-select:none; flex-direction:column; font-size:22px; box-shadow:0 4px 6px rgba(0,0,0,0.4);}
#craftWall { right:30px; bottom:30px; background:#964B00; }
#craftReinforced { right:130px; bottom:30px; background:#D2B48C; }
#craftAxe { right:230px; bottom:30px; background:#333; }
#mineBtn { right:30px; bottom:130px; background:#f55; }
#waveDisplay { position:absolute; top:20px; left:50%; transform:translateX(-50%); font-size:32px; color:white; text-shadow:1px 1px 4px black; pointer-events:none;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="ui">
  <div id="mineBtn" class="btn">‚õè</div>
  <div id="craftWall" class="btn">‚óºÔ∏è<span style="font-size:12px;">3 wood</span></div>
  <div id="craftReinforced" class="btn">üü´<span style="font-size:12px;">30 wood</span></div>
  <div id="craftAxe" class="btn">ü™ì<span style="font-size:12px;">15 wood</span></div>
  <div id="waveDisplay"></div>
</div>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
function resizeCanvas(){ canvas.width = innerWidth; canvas.height = innerHeight; }
resizeCanvas();
addEventListener("resize", resizeCanvas);

// Game state
let player = { x: 0, y: 0, hasAxe: false };
let wood = 0, wave = 0, wavesDone = false;
let trees = [], enemies = [], walls = [];
let base = { x: 0, y: 0, hp: 250, maxHp: 250 };
let gameOver = false, gameStarted = true;
let highScore = Number(localStorage.getItem("warHighScore") || 0);
const waveDisplay = document.getElementById("waveDisplay");

// Waves config
const waves = [
  {normal:5,big:0},
  {normal:10,big:0},
  {normal:15,big:2},
  {normal:20,big:3},
  {normal:25,big:5},
  {normal:30,big:3},
  {normal:35,big:4},
  {normal:40,big:4},
  {normal:45,big:5},
  {normal:50,big:10},
];

// --- Touch joystick (relative to touch start) ---
let joyX = 0, joyY = 0;
let activeTouchId = null;
let touchStart = null;

document.body.addEventListener("touchstart", (e) => {
  for (const t of e.changedTouches) {
    // ignore touches that start on UI buttons
    if (t.target && t.target.closest && t.target.closest(".btn")) continue;
    if (activeTouchId === null) {
      activeTouchId = t.identifier;
      touchStart = { x: t.clientX, y: t.clientY };
      updateJoyFromTouch(t);
    }
  }
}, { passive: true });

document.body.addEventListener("touchmove", (e) => {
  for (const t of e.changedTouches) {
    if (t.identifier === activeTouchId) updateJoyFromTouch(t);
  }
}, { passive: true });

document.body.addEventListener("touchend", (e) => {
  for (const t of e.changedTouches) {
    if (t.identifier === activeTouchId) {
      activeTouchId = null;
      touchStart = null;
      joyX = joyY = 0;
    }
  }
}, { passive: true });

function updateJoyFromTouch(t) {
  if (!touchStart) return;
  const dx = t.clientX - touchStart.x;
  const dy = t.clientY - touchStart.y;
  const d = Math.min(Math.hypot(dx, dy), 50);
  const a = Math.atan2(dy, dx);
  joyX = Math.cos(a) * d / 50;
  joyY = Math.sin(a) * d / 50;
}

// Optional: mouse controls for desktop testing (relative drag)
let mouseDown = false, mouseStart = null;
canvas.addEventListener("mousedown", e => {
  const el = document.elementFromPoint(e.clientX, e.clientY);
  if (el && el.closest && el.closest(".btn")) return;
  mouseDown = true;
  mouseStart = { x: e.clientX, y: e.clientY };
  const fakeTouch = { clientX: e.clientX, clientY: e.clientY };
  touchStart = { ...mouseStart };
  updateJoyFromTouch(fakeTouch);
});
window.addEventListener("mousemove", e => {
  if (!mouseDown) return;
  const fakeTouch = { clientX: e.clientX, clientY: e.clientY };
  updateJoyFromTouch(fakeTouch);
});
window.addEventListener("mouseup", () => {
  mouseDown = false;
  touchStart = null;
  joyX = joyY = 0;
});

// --- Buttons ---
let mining = false;
const mineBtn = document.getElementById("mineBtn");

// prevent mineBtn touches from interfering with joystick
mineBtn.addEventListener("touchstart", (e) => { 
  mining = true; 
  e.stopPropagation(); 
}, { passive: true });

mineBtn.addEventListener("touchend", (e) => { 
  mining = false; 
  e.stopPropagation(); 
}, { passive: true });

mineBtn.addEventListener("mousedown", (e) => { 
  mining = true; 
  e.stopPropagation(); 
});
mineBtn.addEventListener("mouseup", (e) => { 
  mining = false; 
  e.stopPropagation(); 
});

document.getElementById("craftWall").addEventListener("touchstart", () => {
  if (wood >= 3) { wood -= 3; walls.push({ x: Math.round(player.x/50)*50, y: Math.round(player.y/50)*50, hp: 16, maxHp: 16, type: 'normal' }); }
}, { passive: true });
document.getElementById("craftReinforced").addEventListener("touchstart", () => {
  if (wood >= 30) { wood -= 30; walls.push({ x: Math.round(player.x/50)*50, y: Math.round(player.y/50)*50, hp: 170, maxHp: 170, type: 'reinforced' }); }
}, { passive: true });
document.getElementById("craftAxe").addEventListener("touchstart", () => {
  if (!player.hasAxe && wood >= 15) { wood -= 15; player.hasAxe = true; }
}, { passive: true });

// --- Trees ---
function spawnTrees(){
  for(let i=0;i<120;i++) trees.push({x:Math.random()*2000-1000,y:Math.random()*2000-1000,hp:12,gaveWood:false});
}
function spawnTreeRandom(){trees.push({x:Math.random()*2000-1000,y:Math.random()*2000-1000,hp:12,gaveWood:false});}

// --- Wave management ---
let currentWaveIndex = 0;
let waveActive = false;
let countdownRunning = false;

function startNextWave() {
  if (currentWaveIndex >= waves.length){ wavesDone = true; waveDisplay.innerText = "All waves complete!"; return; }
  countdownRunning = true;
  let countdown = 10;
  waveDisplay.innerText = `Wave ${currentWaveIndex+1} starting in ${countdown}`;
  const interval = setInterval(() => {
    countdown--;
    if (countdown > 0) {
      waveDisplay.innerText = `Wave ${currentWaveIndex+1} starting in ${countdown}`;
    } else {
      clearInterval(interval);
      countdownRunning = false;
      wave = currentWaveIndex + 1;
      waveDisplay.innerText = `Wave ${wave}`;
      const cfg = waves[currentWaveIndex];
      for (let i=0;i<cfg.normal;i++) spawnEnemy(false);
      for (let i=0;i<cfg.big;i++) spawnEnemy(true);
      waveActive = true;
      currentWaveIndex++;
    }
  }, 1000);
}

function spawnEnemy(big=false){
  const a = Math.random()*Math.PI*2;
  enemies.push({ x: base.x + Math.cos(a)*700, y: base.y + Math.sin(a)*700, hp: big ? 120 : 60, big: big });
}

// Spawn initial trees and start first wave
spawnTrees();
startNextWave();

// --- Game loop ---
let camX = 0, camY = 0;
function loop(){
  requestAnimationFrame(loop);
  if (!gameStarted || gameOver) return;

  // Player movement
  player.x += joyX * 3;
  player.y += joyY * 3;

  // Mining/attacking
  if (mining){
    trees.forEach(t=>{
      if (dist(player,t) < 45){ 
        t.hp -= (player.hasAxe ? 10 : 4); 
        if (t.hp <= 0 && !t.gaveWood){ wood += 3; t.gaveWood = true; setTimeout(spawnTreeRandom, 3000); }
      }
    });
    enemies.forEach(en => { if (dist(player,en) < 45) en.hp -= (player.hasAxe ? 10 : 4); });
  }

  // Remove dead
  trees = trees.filter(t => t.hp > 0 || !t.gaveWood);
  enemies = enemies.filter(en => en.hp > 0);
  walls = walls.filter(w => w.hp > 0);

  // Enemy AI
  enemies.forEach(en=>{
    let nearWall = walls.find(w => dist(en,w) < 45);
    if (nearWall){ nearWall.hp -= (en.big ? 0.1 : 0.05); return; }
    const dx = base.x - en.x, dy = base.y - en.y, d = Math.hypot(dx,dy);
    if (d !== 0) { en.x += dx/d; en.y += dy/d; }
    if (d < 45){ base.hp -= (en.big ? 0.1 : 0.05); if (base.hp <= 0) flagLost(); }
  });

  // Wave progression
  if (!wavesDone && !countdownRunning && (!waveActive || enemies.length === 0)){
    if (enemies.length === 0){ waveActive = false; startNextWave(); }
    if (wave > highScore){ highScore = wave; localStorage.setItem("warHighScore", highScore); }
  }

  // Camera follows player
  camX = player.x - canvas.width/2;
  camY = player.y - canvas.height/2;

  // Draw world
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.translate(-camX, -camY);

  // Base
  ctx.fillStyle = "#6b4226"; ctx.fillRect(base.x-50, base.y-50, 100, 100);
  ctx.fillStyle = "blue"; ctx.fillRect(base.x-10, base.y-10, 20, 20);

  // Walls
  walls.forEach(w=>{
    ctx.fillStyle = (w.type === 'reinforced') ? "#D2B48C" : "#7b3f00";
    ctx.fillRect(w.x-20, w.y-20, 40, 40);
    if (w.type === 'reinforced'){
      ctx.strokeStyle = "#A0522D";
      for (let i=-15;i<=15;i+=10){
        ctx.beginPath();
        ctx.moveTo(w.x-20, w.y-20+i);
        ctx.lineTo(w.x+20, w.y-20+i);
        ctx.stroke();
      }
    }
    ctx.strokeStyle="black"; ctx.strokeRect(w.x-20, w.y-20, 40, 40);
    ctx.fillStyle="black"; ctx.fillRect(w.x-20, w.y-30, 40, 5);
    ctx.fillStyle="lime"; ctx.fillRect(w.x-20, w.y-30, (w.hp/w.maxHp)*40, 5);
  });

  // Trees
  trees.forEach(t=>{
    ctx.fillStyle="brown"; ctx.fillRect(t.x-5, t.y, 10, 25);
    ctx.fillStyle="green"; ctx.beginPath(); ctx.arc(t.x, t.y, 20, 0, Math.PI*2); ctx.fill();
  });

  // Enemies
  enemies.forEach(en=>{
    ctx.strokeStyle="red"; ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(en.x,en.y-15); ctx.lineTo(en.x,en.y+15); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(en.x-10,en.y); ctx.lineTo(en.x+10,en.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(en.x,en.y+15); ctx.lineTo(en.x-10,en.y+25); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(en.x,en.y+15); ctx.lineTo(en.x+10,en.y+25); ctx.stroke();
    ctx.beginPath(); ctx.arc(en.x,en.y-20,8,0,Math.PI*2); ctx.stroke();
    ctx.fillStyle="black"; ctx.fillRect(en.x-20,en.y-35,40,5);
    ctx.fillStyle="lime"; ctx.fillRect(en.x-20,en.y-35,(en.hp/(en.big?120:60))*40,5);
  });

  // Player
  ctx.strokeStyle="white"; ctx.lineWidth=3;
  ctx.beginPath(); ctx.arc(player.x, player.y-20, 10, 0, Math.PI*2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(player.x, player.y-10); ctx.lineTo(player.x, player.y+20); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(player.x-12, player.y); ctx.lineTo(player.x+12, player.y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(player.x, player.y+20); ctx.lineTo(player.x-10, player.y+35); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(player.x, player.y+20); ctx.lineTo(player.x+10, player.y+35); ctx.stroke();

  // Arrow to base
  const ax = base.x - player.x;
  const ay = base.y - player.y;
  const ang = Math.atan2(ay, ax);
  ctx.save();
  ctx.translate(player.x, player.y - 40);
  ctx.rotate(ang);
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.moveTo(10, 0);
  ctx.lineTo(-8, 6);
  ctx.lineTo(-8, -6);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  ctx.restore();

  // UI overlay
  ctx.fillStyle="white"; ctx.font="20px sans-serif";
  ctx.fillText("Wood: " + wood, 10, 50);
  ctx.fillText("Weapon: " + (player.hasAxe ? "ü™ì Axe" : "üëä Fist"), 10, 75);
  ctx.fillText("Base HP: " + Math.floor(base.hp), 10, 100);
  ctx.fillText("High Score: " + highScore, canvas.width - 180, 25);
}
loop();

function dist(a,b){ return Math.hypot(a.x - b.x, a.y - b.y); }
function flagLost(){
  gameOver = true;
  alert("Base destroyed ‚Äì Game Over! Wave: " + wave);
}
</script>
</body>
</html>
